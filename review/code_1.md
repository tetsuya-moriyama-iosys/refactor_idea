# よくあるレビュー指摘点【コード編1】

> [!NOTE]  
> 1ヶ月目でも意識できる内容がこっち。頭の片隅にあるだけで明らかにその後のキャリアに差が出るはず。
> 簡単な内容だからといって侮ることなかれ。数年選手でもできてない人は体感かなり多い。ちなみにレビュアー目線だと、2年目とかで**このレベルの内容を指摘した時点でその人に何も期待しなくなる。** それぐらい常識的な話。

なるべく易しい順に並べているつもりです。
常識的な内容しかないとはいえ、初学者が一気に理解しようとすると頭パンクすると思うので、さっと流し読みしてレビュー指摘貰った時に立ち返るぐらいがいいと思います。

- [命名の基礎](#命名の基礎)

## 命名の基礎

### 例：一般的な言い回し

こういう時はこういう表現、って決まっているものがいくつかある。逆にそれ以外の単語を使うことはほぼない。
(※割と無意識に使ってるので、気づき次第追記します)

| 単語 | 意味 |
| --- | --- |
| required | 必須 |
| is, has, flg | bool値 |
| list, set, 複数形 | 配列 |
| disabled, readonly | 非活性・読み取り専用(※厳密には区別はある) |

### 例：型がわかる命名

最も初歩的な例としては、booleanの時はそれとわかる真偽値を命名に与えるというのをよくやります。

```typescript
// 何が入ってるかわからん
const data: boolean;

// なんとなく用途が想像できる
const isPdf: boolean;
const hasData: boolean;
const adminFlg: boolean;
```
このように、変数名から中身が想像できるというのは考えて命名すべきです。例えば配列とかだと下記のような例がある。


```typescript
const user: User[]; // NG! userという名前から配列であることがわからない
// OK
const users: User[]
const userList: User[]
```

配列の類は、配列であることがわかる命名にしましょう。少なくとも複数形であることが必要なケースが多い。

あと、レビューしてて特に多かったのが下記のようなパターン。


```typescript
// インターフェースのNG例
type UserList={
  name: string,
  email: string,
}
```
リストのインターフェースになぜか複数形を想起される名前(List)を使うパターン。リストの型だからリストって名付けたんだと思うけど、こういうことをするとコードが難読化します。このパターン100回ぐらい指摘しました


```typescript
// 例
const users: UserList[]; // 多次元配列！？
```

Listの中は当然配列だと思うのですが、これを見て単なるユーザーの配列であることがわかる人なんていないです。Listの配列ってなんだ！？ってなって定義を見て何がリストだ！ただのユーザー情報じゃねえか！ってなった時は書いた奴を恨みます。無駄な時間です……

**補足：接頭辞について**

booleanだとis～、has～などの接頭辞をつける方がメジャーではある(僕は好み)が、プロジェクトによっては付けるなというところもある。例えば･･････

```typescript
// このへんは一目でbooleanということは分かる
const open
const close
const disabled
```
こういうのにいちいちis～とか付けるとトートロジーになるので、それを嫌う人もいる。古のハンガリアン記法みたいになるからですね。
個人的には視認のしやすさ、および対称性(他につけてるならopenとかも合わせるべき)を持たせてisをつける派ですが、このへんはプロジェクトルールによる。

### 例：スネークケースやパスカルケース
TypeScriptならキャメルケース(型名はパスカルケース)だし、SQLなんかだとスネークケースかな、といったように、変数名の形は型や言語、プロジェクトに合わせて下さい。

```typescript
//スネークケース
snake_case
//キャメルケース
camelCase
//パスカルケース
PascalCase
```

他にもPHPならオブジェクトはキャメルケースとかそういうのあった気がする。いわゆる共通認識ってやつですね。プロジェクトによって多少は違うと思うんですけど、とにかく合わせて下さい。

ちなみにこういうこと言うとアレなんですけど、2年目とかになると指摘された瞬間、センスないなって思っちゃいます。コピペならしょうがないんですけど、変な命名は書いてて気持ち悪くなるんですよね普通。
それぐらいありえないことではあるので、最初から意識しておくとベターです。

## 命名に意味を持たせる

### 例：汎用的すぎる名前・異常な命名
初心者がやりがちなミスとして、なんとなくで引数を命名するというのをやりがちです。
命名こそしっかり考えてつけるべきであり、なるべくわかりやすくを心がけて下さい。適切な命名ができていると余計なことを考えずに済みます。

```typescript
// やりがちな例
const date = new Date(); // dateって、何のdate？
// 微妙な例
const today = new Date(); // bad:時刻についての情報が変数名から抜け落ちている。
//改善例
const currentDate  = new Date(); // 「今」であることが変数名からわかる
```
その他の例として、型と命名が一致しないという例もありがちです。

```typescript
function download(date: Date, dataType: boolean, isPdf: boolean){...}
```
dataTypeという引数がbooleanというのは意味がわかりません。これはフラグなのか、それともデータ形式なのか？

```typescript
function download(date: Date, dataType: "summary"|"detail", isPdf: boolean){...}
```
こういう感じであればdataTypeという命名に正当性が持たされますね。

さらに、この関数名のdownloadって何をダウンロードするものか伝わりませんね。

```typescript
function reportDownload(date: Date, dataType: "summary"|"detail", isPdf: boolean){...}
//呼び出し元
reportDownload(currentDate, "summary", true)
```
こんな風にすれば、呼び出し元からも何がダウンロードされるかわかりますね。最後のisPdfも呼び出し元からは分かりづらいので…

```typescript
function reportDownload(date: Date, dataType: "summary"|"detail", extension: "pdf"|"csv"){...}
//呼び出し元
reportDownload(currentDate, "summary", "csv") // この一行だけでも何をやってるかわかる！
```

> [!NOTE]頻出・ふんわり単語一覧
> data
> value
> flag
> status
> result
> list
> check

変数名でこのあたりが単発で出てきてたら、命名が怪しい(何か形容詞をつけるべき)可能性が高い。

このように、命名はしっかりと考えられて与えられると認知の難易度が下がり、品質の高いコードになっていきます。

### 例：ループ処理のループ変数
ループ処理ってテキトーに書きがちですけど、ここもちょっと気をつけるだけで認知が易しくなる。

```typescript
// よくない例
const userList = users.map(data=>{
  id: data.id //dataって何だっけ......？
  name: data.name
})

// こうして欲しい
const userList = users.map(user=>{
  id: user.id 
  name: user.name
})
```

よくある別例としてループ変数にiとかjとか採用しがちな人は危険信号です。というか基本使うべきではないです。これは中級者に多いイメージ。インデックスを示す時ぐらいしか使わないかな。
それもindexとかrow,columnとか別の表記の方がわかりやすい例とかありそう。誰が見ても確実に意図が伝わるって時以外こういう意味のない名前はやめた方がいいです。

### 例：命名の対称性
同じ類の変数には、対称性をもたせた命名をすべきです。
```typescript
const open:boolean = false // エラーダイアログの表示状態
const confirmOpen: boolean =false // 確認ダイアログの表示状態
```
この2つは似たようなものを示していますが、openという汎用的な命名に対して、confirmOpenという命名は限定的な命名です。この2つのものが似たような用途を持つにもか関わらず、あたかも全く別のもののような定義のされかたをしておりこれはコードの難読化につながります。

```typescript
const errorOpen:boolean = false
const confirmOpen:boolean = false
```
このように、並列関係にある命名は対称性を持った命名にすることが望ましいです。

実装時は問題なくても後から機能を付け足したパターンだと多くなるかもです。並列関係にあるものを追加した際は横着せずに、対称性のある名前を付け直しましょう。

余談ですが、例としてのわかりやすさを優先してダイアログを取り上げましたが、ダイアログの状態は基本的に1つで事足りることが多いはずです。→
【React･フロント編】よくあるレビュー指摘点(wip) | ダイアログにおけるテンプレートリテラルの活用例 

### 例：トートロジー・命名の錯綜
```typescript
interface Props{
  labelName1: string;
  labelName2?: string;
  phoneNo1: string | null;
  phoneNo2: string | null;
  phoneNo3: string | null;
  telNo1?: string | null;
  telNo2?: string | null;
  telNo3?: string | null;
  telFlg?: string | null; // 日本国内に電話番号がないかどうかのフラグ 
}
```
よくある電話番号2つを表示するコンポーネントですね。上記のインターフェースの問題点を指摘してみてください。
実際に指摘されてたのに加えて、僕自身の観点も加えて書き連ねてみます。

 
**改善点①：トートロジー**

labelもnameも同じようなことを言ってるので、label1とlabel2でいいと思います。

**改善点②：命名の錯綜**

phoneとtelの違いって見てわかりますかね？たぶん固定電話と携帯電話という概念だと普通は思うんですが、だったらphoneとmobileで良くないか？そうでなく、並列関係にあるのならtel1とtel2とかにするべきです。
どちらにせよ、命名からポリシー(伝えたいこと)を感じません。

**改善点③：何のフラグ？**

telFlgって何のフラグか名前から類推できません。一応コメントで補足しましたが、本来noDomesticPhoneみたいな命名だと、コメントの補足って要らなくなりません？
(この命名はchatGPTに投げました。命名も悩んだらAIにやらせればいいのです)

**改善点④：一般的な命名規則に従う**

またさっきのtelFlgの話ですが、実はしれっとstringが渡されています。
Flgって言ったら普通booleanです。コード値なら～Codeという命名にするのが一般的です。

以下、命名には関係ないが、実はまだ改善点はあるので簡単に書き連ねる。

**改善点⑤：不要なoptional**
```typescript
telNo1?: string | null;
```
nullとundefinedの区別ってこのコンポーネント目線だと要らないと思います。


**改善点⑥：論理構造を限定できない(これは中～上級者向け)**
そもそもlabel+no1～3って1つの「電話番号インターフェース」にできるので、そのように書くのがいいと思います。labelName1とphoneNo1～3ってセットで存在する概念ですよね？あと、no2だけがあるパターンってありうるのでしょうか？
あと最初の定義だとlabelName2がなくてtelNo1～3があるパターンもありえちゃうんですけど、意味不明なので考えたくないです。

```typescript
type Phone = {
  name: string // 名前は少なくとも存在する
} & PhoneNo

type PhoneNo =
  | { no1: string; no2: string; no3: string } // 全部埋まっている
  | { no1: null; no2: null; no3: null };      // 全部 null
  // ↑そもそもPhoneNo | null みたいな形の方がわかりやすいかも？どっちがラクかによる。

interface Props{
  phone: Phone
  mobile: Phone | null // 携帯電話は任意表示項目ということが伝わる
  noDomesticPhone: boolean
}
```
あくまで例ですがこんな風に定義して渡した方が明確なんじゃないでしょうか。
まあいろいろ検討すべき余地はあるんですけど、考え方の一例として捉えてくれると助かります。

固定電話をphoneと表現するのは微妙感あるんですが、かといってhome phoneとかlandlineとか、日本語話者にとっては馴染みないからなぁとか考えなくはないですが、まあ及第点でしょう……(より良いアイデアあったら教えてください)

具体の話→
リファクタサンプル：型で論理構造を表現する 

> [!NOTE]
> 正直これはちょっと厳格すぎるかもなぁ、ラベル表示はラベル表示としてインターフェースは分けた方が書きやすそうかなぁとか思わんこともないです。ただ、少なくとも一回検討してから最終的な形を決めるべき、という話です。最終的にはユースケースによります。ただ、基本的には厳格にすることを推奨します。考えることが減るので。

何も考えずにコードを書いてると、最初にあげた例みたいになりがちですが、変数の命名についてもこのようにレビュー観点になります。論理構造云々はレビューだと妥協しちゃう感ありそうですが……

## マジックナンバーは何があっても禁止

僕が業務でコード書き始めて最初に指摘されたのがこれですね(笑)

### 例：用途不明な数字
```typescript
function calculate(price: number): number {
  return price * 0.2;
}
```
例えば、priceに0.2を掛ける関数がcalculateって定義されてるんですけど、この0.2って何のことだと思います？
割引とか税率とか、VIP価格とか？と、疑問を持たせる時点でこのコードは悪です。

```typescript
TAX_RATE = 0.2
function calculateTax(price: number): number {
  return price * TAX_RATE ;
}
```
ということで、コード上のあらゆる数値は定数にしましょう。これなら誰が見ても税率計算ってわかります。まあ、関数の名前も不適切なので変えちゃいましょう。calculateTaxなら、何をする関数なのか一目でわかりますね。

### 例：配列の添字
```typescript
const result=getUserData(id); // [id, name, email]のタプルが返ってくる
const name=result[1]; //え、この1って何？
```
こういうのもよくある例ですね。関数の返り値がタプルだったりして、[1]でアクセスせざるを得ない例です。この1も、この行だけ見て意味不明なので定数にすべきです。

```typescript
const NAME_COLUMN = 1
const result=getUserData(id);
const name=result[NAME_COLUMN];
```
まあ、そもそもこの関数の作りがクソみたいな話はありますが、とりあえず意味不明な数字は全部定数にしましょう。
基本的にはコード上に生の数字が出てくるのはすべてNGぐらいに思ってていいです。

### 例外：どうしようもない時は諦める
```typescript
const result = getUser(id); // ライブラリの都合上、[モデル, モデル外の値1, 2...]が返る
const user=result[0] // result[MAIN_DATA]とかにするの......？
```
例えばORMとかだと、メインとなるモデルが[0]で返ってくるが、同時に他の値が[1],[2]で返ってくるパターンがある。まあ、理想としてはそれぞれをオブジェクトに格納する変換関数を作ることではあるんですが、この1行で済むことに対してそんな大掛かりなことをするのはやっぱりめんどくさい。し、ライブラリの挙動であればある程度の共通認識はあるはず、ということでこういう場合はコメントで[0]の意味を説明すればOKということにしています。僕は。
逆に加工することでライブラリの標準動作から逸れ、認知の難易度を上げてしまうという側面もこの場合あるので。

```typescript
const result = baseQuery.execute()

// どっちが見やすい？
const user=result[USER_DATA]
const user=result[0] // タプルで返ってくるため
```
つまり、**どちらが認知が易しいか**です。USER_DATAとか書かれると、その内容が0、つまりモデルと直接関連があるタプルかどうかが隠蔽されてしまうんですが、0であればselect(*)した時のものの類が返ってきてるっていうのが直感的にわかるので、この場合は変に定数にするよりコメントにした方が認知が易しいです。

最初の例(getUserData)との違いは、ライブラリ由来であり共通認識があるか否かですね。自作関数だと[0]とか言われても分かんないので、定数化すべきです。
要は、読み手がどれだけ脳死でコードを読めるかという話です。コードは頭を使わずに読むものです。

## 条件分岐をシンプルに

### 例：falsyチェック
```typescript
const displayName = name ? name : "名無し"
```
こういうのって冗長なのでもう少し短くできないか考える。

```typescript
const displayName = name || "名無し"
```
このようにfalsyな値で分岐できる場合はこのように書いたほうがシンプルです。
同じことを2回書くのはコードのにおいとしてレビュー指摘点によくなります。書きながらもっとシンプルにならないか？と考えChatGPTとかに入れると良いです。別に頑張って自分で考える必要とかないです。

## nullableについて
その値がnullになりうるかどうか…というのはきちんと意識するべきだし、nullであるべきでないならその可能性は最初から排除すべき。

## 非null値
本来nullになりえないものについてnullかも知れない…みたいなコードにしてる例ってほんとに多い。この時点でこの値には◯◯が入ってる、みたいなことを把握しながら作ってたら余計なこと考えなくて済むのに。みんなそんな仕事が好きなんですか？ｗ
```typescript
function getUserName(user: User) {
  if (user !== null && user !== undefined) { // 不要なnullチェック
    if (user.name !== null && user.name !== undefined) { // 不要なnullチェック
      return `ユーザー名は ${user.name} です。`;
    } else {
      return 'ユーザー名が設定されていません。';
    }
  } else {
    return 'ユーザー情報が存在しません。';
  }
}
```
例えば、userの引数はUser型って決めてるので、少なくともnullである可能性はない。(厳密には定義によるが、マトモな人はそんな紛らわしい定義をしない)
で、名前についても実際定義によるが、普通にname: stringで定義していればnullableでないのでif文自体不要です。ということを理解した上で書けばこのような本来考えなくてもいいことを考える必要はないのですが、割とこのようなケースは多い。

https://github.com/tetsuya-moriyama-iosys/refactor_idea/blob/images/image-20250126-233659.png
nullかどうかわからない…って時はエディタに説明してもらえばいいです。オンマウスで何がありうるかを教えてくれる。
機械がnullの可能性ないって言ってたら100%ないって思ってOKです。そもそもnullの可能性があるかどうか不安なコードはそもそもその時点で何かが間違っています。書いた本人が追えてないコードは誰も理解できません。

そもそも、その関数にとってnullである必要がないものは最初からnullを受け取らない作りにすべきです。そうすれば最初からこのような余計なことを考えなくて済むのです。

考えたくない可能性を最初から排除するようなコードを書いておけばいい話です。もうこの時点でnullであって欲しくないなって思ったコードは、例外を投げるとか早期リターンしたりしてnullの可能性を排除すればOK。

## nullとundefinedの区別

javascriptでいうと、nullとundefinedを区別するみたいな話があるが、引数をオプショナルにするかとかそのへん考えて実装するべきという話。

```typescript
interface PhoneProps{
  telNo?: string | null
}
命名の話をした時に触れたものです。→
【WIP】よくあるレビュー指摘点【はじめに&過去に読んだもの紹介】 | 例：トートロジー・命名の錯綜 

値なしを示す引数としてはnullとどっちかでいいと思うという話はしました。だって「値がある」「値がない」以外の区別ってこの変数名からなさそうですよね？「フィールドはあるが値が与えられていない」みたいな状態を区別するものとは到底思えませんよね？

もちろん、nullもundefinedも受け取れるようにした方がいいのでは？という気持ちもわかります。そうすれば、このコンポーネントを呼び出す側がラクですし。



<Phone/> // optionalなのでこれで呼び出せる
<Phone telNo={customer?.telNo}/> // telNoがnullでも、customerが空でも気にせず呼び出せる
<Phone telNo={customer?.telNo ?? undefined}/> //ダルくね？
ただ、コンポーネントや関数というのは堅牢であればあるほどバグを生まないので良いのです。

このPhoneコンポーネントの実装者の気持ちになって考えてみてください。telNoがnullなのかundefinedなのか、それとも空文字なのかとか考えるのダルくないですか？
このPhoneコンポーネントの中の世界では、telNoは「電話番号が渡される」か「nullが渡される」かの2択しか存在しない前提で書きたくないですか？呼び出し元の都合とか知るかよ、お前が合わせろよみたいなスタンスです。だってその方が仕事が減るんだから。

 

どちらに寄せるのがいいかは感覚で決めてますが、フィールドにあるのが普通かそうでないかとか、実装がラクかどうかで決めるといいと思います。例えば上述の例だとcustomerから呼び出されることが過半数なのであれば、telNoというフィールド自体はあるというのが普通なのでstring | nullの方が自然に呼び出せますし、デフォルト値をつけたい場合はoptionalに絞った方が意図が明確になりますし、ミスってnullを渡してよくわからないことになるのを防止できたりします。

ので、どっちに寄せるのが普通とかはないと思いますが、nullの方が字面が直感的なので、デフォルト値がない場合はnullableに寄せる方がいいのかなーとか思います。ぶっちゃけこの辺は感覚です。



<Phone telNo={customer?.telNo ?? null}/> // こっちの方が字面はきれい
<Phone telNo={customer?.telNo ?? undefined}/> // デフォルト値を設定する場合はこうなる
<Phone telNo={customer?.telNo || null} /> // falsy 値全体 (undefined, "") に対応したパターン
あんまり || を使った書き方ってやらないので忘れてたんですけど、これいいですね。



interface Props{
  telNo: Exclude<string, ""> | null //空文字がありえないことを示唆できる 
}
このようなコードは考えることが1つ減ってベターです。

関連：
リファクタサンプル：型で論理構造を表現する 

この話は僕の感覚の話なので、一般的かどうかは知らないです。
Phoneみたいなコンポーネントだと、呼び出し側の都合を考えてundefinedもnullも許容するというのは実は全然ありうると思っていますが、基本的には呼び出し元の都合を考えないコンポーネントの方が堅牢で自然です。つまり「利便性を踏まえて分かった上でやっている」のと「なんとなくやっている」の違いがあることが大事です。

例：空配列とnull(※ちょい慣れた人向け)

配列について、nullと区別すべきものなのかどうかというのは常に考えた方がシンプルになります。



const users = []
const users = null
// この両者の意味が同じなのであれば、空配列にまとめるとnullの可能性を排除できる
const users: User[]
if(users && user.length > 0)// nullがあると存在チェックはこうしなくてはいけないが
if(users.length > 0)// nullの可能性がないとこれで十分になる
逆に、APIから結果を取得してその結果を配列に格納する…みたいなパターンだと、null=未ロードという意味が与えられるので、区別する意味が生まれます。



// Reactだとこういうことはよくやる(逆にそれ以外の言語だとやらないような...？)
const [users, setUsers] = setState<User[]|null>(null)
useEffect(()=>{
  (async ()=>{
    response = await getUserList();
    setUsers(response.data ?? [])
  })()
},[])
return (<>
  {users == null && <>ローディング中</>}
  {users != null && users.map((user)=>{return <>{user.name}</>})}
)
まあ、要は余計なnullの可能性を排除するコードを書く意識、というのは考えることを減らすために重要ではあります。

型についての意識

例1：Any型は何があっても禁止

コード中にAnyとか出てくるとほぼ確実にレビューでリジェクトします。



function add(a: number, b: number): any {
  return a + b;
}
const total=add(4,5) //totalはnumberに決まってるのに、anyで定義してるせいで型推論が効かない
......
const result=calc(total) //totalって何が入ってるんだっけ？
こういう余計なトラブルを抱えるのでコード中のanyは何があっても修正対象です。

ただ、ライブラリを使ってたりすると返り値の型がよくわかんないからどうしよう……っていうパターンはよくあります。

Open image-20250126-233659.png
image-20250126-233659.png
そういう場合も、ハイライトしたり、直接定義元にジャンプしたり(Ctrl押しながらクリックしたり、右クリックメニューの中にあったりします)すると型はだいたいexportされてるのでそれを使えばいいです。この場合、PluginApiとか渡ってくるらしいし、引数もPropsとかSlotsとかいう型が用意されてるので、変数として使う際はこれをimportして使うべきという話ですね。ちょっと名前が普遍的すぎるのでエイリアスつけた方が良さそうな気もしなくもないですが。

例2：具体的なデータ型を指定する



function getUserData(id:number):Record<str,any>{...}
ユーザーデータを取得する関数ですが、返り値がRecord<str,any>っていうのが良くないです。このままだとユーザーデータの中身がブラックボックスです。



type User={
  name: string
  email: string
  age: number
}
function getUserData(id:number):User{...}
const user = getUserData(1);
const name = user.name; //型推論が効く。
const fuga = user.fuga; //存在しないのでエラーが出る
// (発展)より厳格な型(正直ここまでやる必要があるかどうかは微妙だが、僕は好み)
type User={
  name: Exclude<string,"">;
  email: Exclude<string,"">;
  age: Exclude<number, NaN>;
}
例3：推論される型は推論に任せる

さっきと言ってることが逆になりますが、型推論により導き出される型がある場合はそれに任せた方が良いケースが多いです。
